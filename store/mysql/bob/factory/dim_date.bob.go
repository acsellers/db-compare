// Code generated by BobGen mysql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"testing"
	"time"

	"github.com/aarondl/opt/omit"
	models "github.com/acsellers/golang-db-compare/store/mysql/bob/models"
	"github.com/jaswdr/faker/v2"
	"github.com/stephenafamo/bob"
)

type DimDateMod interface {
	Apply(context.Context, *DimDateTemplate)
}

type DimDateModFunc func(context.Context, *DimDateTemplate)

func (f DimDateModFunc) Apply(ctx context.Context, n *DimDateTemplate) {
	f(ctx, n)
}

type DimDateModSlice []DimDateMod

func (mods DimDateModSlice) Apply(ctx context.Context, n *DimDateTemplate) {
	for _, f := range mods {
		f.Apply(ctx, n)
	}
}

// DimDateTemplate is an object representing the database table.
// all columns are optional and should be set by mods
type DimDateTemplate struct {
	Date        func() time.Time
	Month       func() int32
	Year        func() int32
	Quarter     func() int32
	DayOfWeek   func() int32
	DayOfMonth  func() int32
	DayOfYear   func() int32
	WeekOfYear  func() int32
	WeekOfMonth func() int32

	f *Factory

	alreadyPersisted bool
}

// Apply mods to the DimDateTemplate
func (o *DimDateTemplate) Apply(ctx context.Context, mods ...DimDateMod) {
	for _, mod := range mods {
		mod.Apply(ctx, o)
	}
}

// setModelRels creates and sets the relationships on *models.DimDate
// according to the relationships in the template. Nothing is inserted into the db
func (t DimDateTemplate) setModelRels(o *models.DimDate) {}

// BuildSetter returns an *models.DimDateSetter
// this does nothing with the relationship templates
func (o DimDateTemplate) BuildSetter() *models.DimDateSetter {
	m := &models.DimDateSetter{}

	if o.Date != nil {
		val := o.Date()
		m.Date = omit.From(val)
	}
	if o.Month != nil {
		val := o.Month()
		m.Month = omit.From(val)
	}
	if o.Year != nil {
		val := o.Year()
		m.Year = omit.From(val)
	}
	if o.Quarter != nil {
		val := o.Quarter()
		m.Quarter = omit.From(val)
	}
	if o.DayOfWeek != nil {
		val := o.DayOfWeek()
		m.DayOfWeek = omit.From(val)
	}
	if o.DayOfMonth != nil {
		val := o.DayOfMonth()
		m.DayOfMonth = omit.From(val)
	}
	if o.DayOfYear != nil {
		val := o.DayOfYear()
		m.DayOfYear = omit.From(val)
	}
	if o.WeekOfYear != nil {
		val := o.WeekOfYear()
		m.WeekOfYear = omit.From(val)
	}
	if o.WeekOfMonth != nil {
		val := o.WeekOfMonth()
		m.WeekOfMonth = omit.From(val)
	}

	return m
}

// BuildManySetter returns an []*models.DimDateSetter
// this does nothing with the relationship templates
func (o DimDateTemplate) BuildManySetter(number int) []*models.DimDateSetter {
	m := make([]*models.DimDateSetter, number)

	for i := range m {
		m[i] = o.BuildSetter()
	}

	return m
}

// Build returns an *models.DimDate
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use DimDateTemplate.Create
func (o DimDateTemplate) Build() *models.DimDate {
	m := &models.DimDate{}

	if o.Date != nil {
		m.Date = o.Date()
	}
	if o.Month != nil {
		m.Month = o.Month()
	}
	if o.Year != nil {
		m.Year = o.Year()
	}
	if o.Quarter != nil {
		m.Quarter = o.Quarter()
	}
	if o.DayOfWeek != nil {
		m.DayOfWeek = o.DayOfWeek()
	}
	if o.DayOfMonth != nil {
		m.DayOfMonth = o.DayOfMonth()
	}
	if o.DayOfYear != nil {
		m.DayOfYear = o.DayOfYear()
	}
	if o.WeekOfYear != nil {
		m.WeekOfYear = o.WeekOfYear()
	}
	if o.WeekOfMonth != nil {
		m.WeekOfMonth = o.WeekOfMonth()
	}

	o.setModelRels(m)

	return m
}

// BuildMany returns an models.DimDateSlice
// Related objects are also created and placed in the .R field
// NOTE: Objects are not inserted into the database. Use DimDateTemplate.CreateMany
func (o DimDateTemplate) BuildMany(number int) models.DimDateSlice {
	m := make(models.DimDateSlice, number)

	for i := range m {
		m[i] = o.Build()
	}

	return m
}

func ensureCreatableDimDate(m *models.DimDateSetter) {
	if !(m.Date.IsValue()) {
		val := random_time_Time(nil)
		m.Date = omit.From(val)
	}
	if !(m.Month.IsValue()) {
		val := random_int32(nil)
		m.Month = omit.From(val)
	}
	if !(m.Year.IsValue()) {
		val := random_int32(nil)
		m.Year = omit.From(val)
	}
	if !(m.Quarter.IsValue()) {
		val := random_int32(nil)
		m.Quarter = omit.From(val)
	}
	if !(m.DayOfWeek.IsValue()) {
		val := random_int32(nil)
		m.DayOfWeek = omit.From(val)
	}
	if !(m.DayOfMonth.IsValue()) {
		val := random_int32(nil)
		m.DayOfMonth = omit.From(val)
	}
	if !(m.DayOfYear.IsValue()) {
		val := random_int32(nil)
		m.DayOfYear = omit.From(val)
	}
	if !(m.WeekOfYear.IsValue()) {
		val := random_int32(nil)
		m.WeekOfYear = omit.From(val)
	}
	if !(m.WeekOfMonth.IsValue()) {
		val := random_int32(nil)
		m.WeekOfMonth = omit.From(val)
	}
}

// insertOptRels creates and inserts any optional the relationships on *models.DimDate
// according to the relationships in the template.
// any required relationship should have already exist on the model
func (o *DimDateTemplate) insertOptRels(ctx context.Context, exec bob.Executor, m *models.DimDate) error {
	var err error

	return err
}

// Create builds a dimDate and inserts it into the database
// Relations objects are also inserted and placed in the .R field
func (o *DimDateTemplate) Create(ctx context.Context, exec bob.Executor) (*models.DimDate, error) {
	var err error
	opt := o.BuildSetter()
	ensureCreatableDimDate(opt)

	m, err := models.DimDates.Insert(opt).One(ctx, exec)
	if err != nil {
		return nil, err
	}

	if err := o.insertOptRels(ctx, exec, m); err != nil {
		return nil, err
	}
	return m, err
}

// MustCreate builds a dimDate and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o *DimDateTemplate) MustCreate(ctx context.Context, exec bob.Executor) *models.DimDate {
	m, err := o.Create(ctx, exec)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateOrFail builds a dimDate and inserts it into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o *DimDateTemplate) CreateOrFail(ctx context.Context, tb testing.TB, exec bob.Executor) *models.DimDate {
	tb.Helper()
	m, err := o.Create(ctx, exec)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// CreateMany builds multiple dimDates and inserts them into the database
// Relations objects are also inserted and placed in the .R field
func (o DimDateTemplate) CreateMany(ctx context.Context, exec bob.Executor, number int) (models.DimDateSlice, error) {
	var err error
	m := make(models.DimDateSlice, number)

	for i := range m {
		m[i], err = o.Create(ctx, exec)
		if err != nil {
			return nil, err
		}
	}

	return m, nil
}

// MustCreateMany builds multiple dimDates and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// panics if an error occurs
func (o DimDateTemplate) MustCreateMany(ctx context.Context, exec bob.Executor, number int) models.DimDateSlice {
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		panic(err)
	}
	return m
}

// CreateManyOrFail builds multiple dimDates and inserts them into the database
// Relations objects are also inserted and placed in the .R field
// It calls `tb.Fatal(err)` on the test/benchmark if an error occurs
func (o DimDateTemplate) CreateManyOrFail(ctx context.Context, tb testing.TB, exec bob.Executor, number int) models.DimDateSlice {
	tb.Helper()
	m, err := o.CreateMany(ctx, exec, number)
	if err != nil {
		tb.Fatal(err)
		return nil
	}
	return m
}

// DimDate has methods that act as mods for the DimDateTemplate
var DimDateMods dimDateMods

type dimDateMods struct{}

func (m dimDateMods) RandomizeAllColumns(f *faker.Faker) DimDateMod {
	return DimDateModSlice{
		DimDateMods.RandomDate(f),
		DimDateMods.RandomMonth(f),
		DimDateMods.RandomYear(f),
		DimDateMods.RandomQuarter(f),
		DimDateMods.RandomDayOfWeek(f),
		DimDateMods.RandomDayOfMonth(f),
		DimDateMods.RandomDayOfYear(f),
		DimDateMods.RandomWeekOfYear(f),
		DimDateMods.RandomWeekOfMonth(f),
	}
}

// Set the model columns to this value
func (m dimDateMods) Date(val time.Time) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Date = func() time.Time { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) DateFunc(f func() time.Time) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Date = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetDate() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Date = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomDate(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Date = func() time.Time {
			return random_time_Time(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) Month(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Month = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) MonthFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Month = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetMonth() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Month = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomMonth(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Month = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) Year(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Year = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) YearFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Year = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetYear() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Year = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomYear(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Year = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) Quarter(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Quarter = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) QuarterFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Quarter = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetQuarter() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Quarter = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomQuarter(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.Quarter = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) DayOfWeek(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfWeek = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) DayOfWeekFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfWeek = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetDayOfWeek() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfWeek = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomDayOfWeek(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfWeek = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) DayOfMonth(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfMonth = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) DayOfMonthFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfMonth = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetDayOfMonth() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfMonth = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomDayOfMonth(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfMonth = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) DayOfYear(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfYear = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) DayOfYearFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfYear = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetDayOfYear() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfYear = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomDayOfYear(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.DayOfYear = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) WeekOfYear(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfYear = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) WeekOfYearFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfYear = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetWeekOfYear() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfYear = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomWeekOfYear(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfYear = func() int32 {
			return random_int32(f)
		}
	})
}

// Set the model columns to this value
func (m dimDateMods) WeekOfMonth(val int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfMonth = func() int32 { return val }
	})
}

// Set the Column from the function
func (m dimDateMods) WeekOfMonthFunc(f func() int32) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfMonth = f
	})
}

// Clear any values for the column
func (m dimDateMods) UnsetWeekOfMonth() DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfMonth = nil
	})
}

// Generates a random value for the column using the given faker
// if faker is nil, a default faker is used
func (m dimDateMods) RandomWeekOfMonth(f *faker.Faker) DimDateMod {
	return DimDateModFunc(func(_ context.Context, o *DimDateTemplate) {
		o.WeekOfMonth = func() int32 {
			return random_int32(f)
		}
	})
}

func (m dimDateMods) WithParentsCascading() DimDateMod {
	return DimDateModFunc(func(ctx context.Context, o *DimDateTemplate) {
		if isDone, _ := dimDateWithParentsCascadingCtx.Value(ctx); isDone {
			return
		}
		ctx = dimDateWithParentsCascadingCtx.WithValue(ctx, true)
	})
}
