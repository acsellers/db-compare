// Code generated by BobGen mysql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/aarondl/opt/omit"
	"github.com/aarondl/opt/omitnull"
	"github.com/shopspring/decimal"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/mysql"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
	"github.com/stephenafamo/bob/dialect/mysql/dm"
	"github.com/stephenafamo/bob/dialect/mysql/sm"
	"github.com/stephenafamo/bob/dialect/mysql/um"
	"github.com/stephenafamo/bob/expr"
	"github.com/stephenafamo/bob/mods"
	"github.com/stephenafamo/bob/orm"
)

// Order is an object representing the database table.
type Order struct {
	ID             int64               `db:"id,pk,autoincr" `
	OrderDate      time.Time           `db:"order_date" `
	CustomerID     null.Val[int64]     `db:"customer_id" `
	DiscountID     null.Val[int64]     `db:"discount_id" `
	OrderType      string              `db:"order_type" `
	Subtotal       decimal.Decimal     `db:"subtotal" `
	DiscountAmount decimal.Decimal     `db:"discount_amount" `
	TaxAmount      decimal.Decimal     `db:"tax_amount" `
	Total          decimal.Decimal     `db:"total" `
	CreatedAt      null.Val[time.Time] `db:"created_at" `
	UpdatedAt      null.Val[time.Time] `db:"updated_at" `

	R orderR `db:"-" `
}

// OrderSlice is an alias for a slice of pointers to Order.
// This should almost always be used instead of []*Order.
type OrderSlice []*Order

// Orders contains methods to work with the orders table
var Orders = mysql.NewTablex[*Order, OrderSlice, *OrderSetter]("orders", buildOrderColumns("orders"), []string{"id"})

// OrdersQuery is a query on the orders table
type OrdersQuery = *mysql.ViewQuery[*Order, OrderSlice]

// orderR is where relationships are stored.
type orderR struct {
	OrderItems    OrderItemSlice    // order_items_ibfk_1
	OrderPayments OrderPaymentSlice // order_payments_ibfk_1
	Customer      *Customer         // orders_ibfk_1
	Discount      *Discount         // orders_ibfk_2
}

func buildOrderColumns(alias string) orderColumns {
	return orderColumns{
		ColumnsExpr: expr.NewColumnsExpr(
			"id", "order_date", "customer_id", "discount_id", "order_type", "subtotal", "discount_amount", "tax_amount", "total", "created_at", "updated_at",
		).WithParent("orders"),
		tableAlias:     alias,
		ID:             mysql.Quote(alias, "id"),
		OrderDate:      mysql.Quote(alias, "order_date"),
		CustomerID:     mysql.Quote(alias, "customer_id"),
		DiscountID:     mysql.Quote(alias, "discount_id"),
		OrderType:      mysql.Quote(alias, "order_type"),
		Subtotal:       mysql.Quote(alias, "subtotal"),
		DiscountAmount: mysql.Quote(alias, "discount_amount"),
		TaxAmount:      mysql.Quote(alias, "tax_amount"),
		Total:          mysql.Quote(alias, "total"),
		CreatedAt:      mysql.Quote(alias, "created_at"),
		UpdatedAt:      mysql.Quote(alias, "updated_at"),
	}
}

type orderColumns struct {
	expr.ColumnsExpr
	tableAlias     string
	ID             mysql.Expression
	OrderDate      mysql.Expression
	CustomerID     mysql.Expression
	DiscountID     mysql.Expression
	OrderType      mysql.Expression
	Subtotal       mysql.Expression
	DiscountAmount mysql.Expression
	TaxAmount      mysql.Expression
	Total          mysql.Expression
	CreatedAt      mysql.Expression
	UpdatedAt      mysql.Expression
}

func (c orderColumns) Alias() string {
	return c.tableAlias
}

func (orderColumns) AliasedAs(alias string) orderColumns {
	return buildOrderColumns(alias)
}

// OrderSetter is used for insert/upsert/update operations
// All values are optional, and do not have to be set
// Generated columns are not included
type OrderSetter struct {
	ID             omit.Val[int64]           `db:"id,pk,autoincr" `
	OrderDate      omit.Val[time.Time]       `db:"order_date" `
	CustomerID     omitnull.Val[int64]       `db:"customer_id" `
	DiscountID     omitnull.Val[int64]       `db:"discount_id" `
	OrderType      omit.Val[string]          `db:"order_type" `
	Subtotal       omit.Val[decimal.Decimal] `db:"subtotal" `
	DiscountAmount omit.Val[decimal.Decimal] `db:"discount_amount" `
	TaxAmount      omit.Val[decimal.Decimal] `db:"tax_amount" `
	Total          omit.Val[decimal.Decimal] `db:"total" `
	CreatedAt      omitnull.Val[time.Time]   `db:"created_at" `
	UpdatedAt      omitnull.Val[time.Time]   `db:"updated_at" `
}

func (s OrderSetter) SetColumns() []string {
	vals := make([]string, 0, 11)
	if s.ID.IsValue() {
		vals = append(vals, "id")
	}
	if s.OrderDate.IsValue() {
		vals = append(vals, "order_date")
	}
	if !s.CustomerID.IsUnset() {
		vals = append(vals, "customer_id")
	}
	if !s.DiscountID.IsUnset() {
		vals = append(vals, "discount_id")
	}
	if s.OrderType.IsValue() {
		vals = append(vals, "order_type")
	}
	if s.Subtotal.IsValue() {
		vals = append(vals, "subtotal")
	}
	if s.DiscountAmount.IsValue() {
		vals = append(vals, "discount_amount")
	}
	if s.TaxAmount.IsValue() {
		vals = append(vals, "tax_amount")
	}
	if s.Total.IsValue() {
		vals = append(vals, "total")
	}
	if !s.CreatedAt.IsUnset() {
		vals = append(vals, "created_at")
	}
	if !s.UpdatedAt.IsUnset() {
		vals = append(vals, "updated_at")
	}
	return vals
}

func (s OrderSetter) Overwrite(t *Order) {
	if s.ID.IsValue() {
		t.ID = s.ID.MustGet()
	}
	if s.OrderDate.IsValue() {
		t.OrderDate = s.OrderDate.MustGet()
	}
	if !s.CustomerID.IsUnset() {
		t.CustomerID = s.CustomerID.MustGetNull()
	}
	if !s.DiscountID.IsUnset() {
		t.DiscountID = s.DiscountID.MustGetNull()
	}
	if s.OrderType.IsValue() {
		t.OrderType = s.OrderType.MustGet()
	}
	if s.Subtotal.IsValue() {
		t.Subtotal = s.Subtotal.MustGet()
	}
	if s.DiscountAmount.IsValue() {
		t.DiscountAmount = s.DiscountAmount.MustGet()
	}
	if s.TaxAmount.IsValue() {
		t.TaxAmount = s.TaxAmount.MustGet()
	}
	if s.Total.IsValue() {
		t.Total = s.Total.MustGet()
	}
	if !s.CreatedAt.IsUnset() {
		t.CreatedAt = s.CreatedAt.MustGetNull()
	}
	if !s.UpdatedAt.IsUnset() {
		t.UpdatedAt = s.UpdatedAt.MustGetNull()
	}
}

func (s *OrderSetter) Apply(q *dialect.InsertQuery) {
	q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
		return Orders.BeforeInsertHooks.RunHooks(ctx, exec, s)
	})

	q.AppendValues(
		bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.ID.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.ID.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.OrderDate.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.OrderDate.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(!s.CustomerID.IsUnset()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.CustomerID.MustGetNull()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(!s.DiscountID.IsUnset()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.DiscountID.MustGetNull()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.OrderType.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.OrderType.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.Subtotal.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.Subtotal.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.DiscountAmount.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.DiscountAmount.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.TaxAmount.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.TaxAmount.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(s.Total.IsValue()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.Total.MustGet()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(!s.CreatedAt.IsUnset()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.CreatedAt.MustGetNull()).WriteSQL(ctx, w, d, start)
		}), bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
			if !(!s.UpdatedAt.IsUnset()) {
				return mysql.Raw("DEFAULT").WriteSQL(ctx, w, d, start)
			}
			return mysql.Arg(s.UpdatedAt.MustGetNull()).WriteSQL(ctx, w, d, start)
		}))
}

func (s OrderSetter) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return um.Set(s.Expressions("orders")...)
}

func (s OrderSetter) Expressions(prefix ...string) []bob.Expression {
	exprs := make([]bob.Expression, 0, 11)

	if s.ID.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "id")...),
			mysql.Arg(s.ID),
		}})
	}

	if s.OrderDate.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "order_date")...),
			mysql.Arg(s.OrderDate),
		}})
	}

	if !s.CustomerID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "customer_id")...),
			mysql.Arg(s.CustomerID),
		}})
	}

	if !s.DiscountID.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "discount_id")...),
			mysql.Arg(s.DiscountID),
		}})
	}

	if s.OrderType.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "order_type")...),
			mysql.Arg(s.OrderType),
		}})
	}

	if s.Subtotal.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "subtotal")...),
			mysql.Arg(s.Subtotal),
		}})
	}

	if s.DiscountAmount.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "discount_amount")...),
			mysql.Arg(s.DiscountAmount),
		}})
	}

	if s.TaxAmount.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "tax_amount")...),
			mysql.Arg(s.TaxAmount),
		}})
	}

	if s.Total.IsValue() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "total")...),
			mysql.Arg(s.Total),
		}})
	}

	if !s.CreatedAt.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "created_at")...),
			mysql.Arg(s.CreatedAt),
		}})
	}

	if !s.UpdatedAt.IsUnset() {
		exprs = append(exprs, expr.Join{Sep: " = ", Exprs: []bob.Expression{
			mysql.Quote(append(prefix, "updated_at")...),
			mysql.Arg(s.UpdatedAt),
		}})
	}

	return exprs
}

// FindOrder retrieves a single record by primary key
// If cols is empty Find will return all columns.
func FindOrder(ctx context.Context, exec bob.Executor, IDPK int64, cols ...string) (*Order, error) {
	if len(cols) == 0 {
		return Orders.Query(
			sm.Where(Orders.Columns.ID.EQ(mysql.Arg(IDPK))),
		).One(ctx, exec)
	}

	return Orders.Query(
		sm.Where(Orders.Columns.ID.EQ(mysql.Arg(IDPK))),
		sm.Columns(Orders.Columns.Only(cols...)),
	).One(ctx, exec)
}

// OrderExists checks the presence of a single record by primary key
func OrderExists(ctx context.Context, exec bob.Executor, IDPK int64) (bool, error) {
	return Orders.Query(
		sm.Where(Orders.Columns.ID.EQ(mysql.Arg(IDPK))),
	).Exists(ctx, exec)
}

// AfterQueryHook is called after Order is retrieved from the database
func (o *Order) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Orders.AfterSelectHooks.RunHooks(ctx, exec, OrderSlice{o})
	case bob.QueryTypeInsert:
		ctx, err = Orders.AfterInsertHooks.RunHooks(ctx, exec, OrderSlice{o})
	case bob.QueryTypeUpdate:
		ctx, err = Orders.AfterUpdateHooks.RunHooks(ctx, exec, OrderSlice{o})
	case bob.QueryTypeDelete:
		ctx, err = Orders.AfterDeleteHooks.RunHooks(ctx, exec, OrderSlice{o})
	}

	return err
}

// primaryKeyVals returns the primary key values of the Order
func (o *Order) primaryKeyVals() bob.Expression {
	return mysql.Arg(o.ID)
}

func (o *Order) pkEQ() dialect.Expression {
	return mysql.Quote("orders", "id").EQ(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		return o.primaryKeyVals().WriteSQL(ctx, w, d, start)
	}))
}

// Update uses an executor to update the Order
func (o *Order) Update(ctx context.Context, exec bob.Executor, s *OrderSetter) error {
	_, err := Orders.Update(s.UpdateMod(), um.Where(o.pkEQ())).Exec(ctx, exec)
	if err != nil {
		return err
	}

	s.Overwrite(o)

	return nil
}

// Delete deletes a single Order record with an executor
func (o *Order) Delete(ctx context.Context, exec bob.Executor) error {
	_, err := Orders.Delete(dm.Where(o.pkEQ())).Exec(ctx, exec)
	return err
}

// Reload refreshes the Order using the executor
func (o *Order) Reload(ctx context.Context, exec bob.Executor) error {
	o2, err := Orders.Query(
		sm.Where(Orders.Columns.ID.EQ(mysql.Arg(o.ID))),
	).One(ctx, exec)
	if err != nil {
		return err
	}
	o2.R = o.R
	*o = *o2

	return nil
}

// AfterQueryHook is called after OrderSlice is retrieved from the database
func (o OrderSlice) AfterQueryHook(ctx context.Context, exec bob.Executor, queryType bob.QueryType) error {
	var err error

	switch queryType {
	case bob.QueryTypeSelect:
		ctx, err = Orders.AfterSelectHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeInsert:
		ctx, err = Orders.AfterInsertHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeUpdate:
		ctx, err = Orders.AfterUpdateHooks.RunHooks(ctx, exec, o)
	case bob.QueryTypeDelete:
		ctx, err = Orders.AfterDeleteHooks.RunHooks(ctx, exec, o)
	}

	return err
}

func (o OrderSlice) pkIN() dialect.Expression {
	if len(o) == 0 {
		return mysql.Raw("NULL")
	}

	return mysql.Quote("orders", "id").In(bob.ExpressionFunc(func(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
		pkPairs := make([]bob.Expression, len(o))
		for i, row := range o {
			pkPairs[i] = row.primaryKeyVals()
		}
		return bob.ExpressSlice(ctx, w, d, start, pkPairs, "", ", ", "")
	}))
}

// copyMatchingRows finds models in the given slice that have the same primary key
// then it first copies the existing relationships from the old model to the new model
// and then replaces the old model in the slice with the new model
func (o OrderSlice) copyMatchingRows(from ...*Order) {
	for i, old := range o {
		for _, new := range from {
			if new.ID != old.ID {
				continue
			}
			new.R = old.R
			o[i] = new
			break
		}
	}
}

// UpdateMod modifies an update query with "WHERE primary_key IN (o...)"
func (o OrderSlice) UpdateMod() bob.Mod[*dialect.UpdateQuery] {
	return bob.ModFunc[*dialect.UpdateQuery](func(q *dialect.UpdateQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Orders.BeforeUpdateHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Order:
				o.copyMatchingRows(retrieved)
			case []*Order:
				o.copyMatchingRows(retrieved...)
			case OrderSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Order or a slice of Order
				// then run the AfterUpdateHooks on the slice
				_, err = Orders.AfterUpdateHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

// DeleteMod modifies an delete query with "WHERE primary_key IN (o...)"
func (o OrderSlice) DeleteMod() bob.Mod[*dialect.DeleteQuery] {
	return bob.ModFunc[*dialect.DeleteQuery](func(q *dialect.DeleteQuery) {
		q.AppendHooks(func(ctx context.Context, exec bob.Executor) (context.Context, error) {
			return Orders.BeforeDeleteHooks.RunHooks(ctx, exec, o)
		})

		q.AppendLoader(bob.LoaderFunc(func(ctx context.Context, exec bob.Executor, retrieved any) error {
			var err error
			switch retrieved := retrieved.(type) {
			case *Order:
				o.copyMatchingRows(retrieved)
			case []*Order:
				o.copyMatchingRows(retrieved...)
			case OrderSlice:
				o.copyMatchingRows(retrieved...)
			default:
				// If the retrieved value is not a Order or a slice of Order
				// then run the AfterDeleteHooks on the slice
				_, err = Orders.AfterDeleteHooks.RunHooks(ctx, exec, o)
			}

			return err
		}))

		q.AppendWhere(o.pkIN())
	})
}

func (o OrderSlice) UpdateAll(ctx context.Context, exec bob.Executor, vals OrderSetter) error {
	_, err := Orders.Update(vals.UpdateMod(), o.UpdateMod()).Exec(ctx, exec)

	for i := range o {
		vals.Overwrite(o[i])
	}

	return err
}

func (o OrderSlice) DeleteAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	_, err := Orders.Delete(o.DeleteMod()).Exec(ctx, exec)
	return err
}

func (o OrderSlice) ReloadAll(ctx context.Context, exec bob.Executor) error {
	if len(o) == 0 {
		return nil
	}

	o2, err := Orders.Query(sm.Where(o.pkIN())).All(ctx, exec)
	if err != nil {
		return err
	}

	o.copyMatchingRows(o2...)

	return nil
}

// OrderItems starts a query for related objects on order_items
func (o *Order) OrderItems(mods ...bob.Mod[*dialect.SelectQuery]) OrderItemsQuery {
	return OrderItems.Query(append(mods,
		sm.Where(OrderItems.Columns.OrderID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os OrderSlice) OrderItems(mods ...bob.Mod[*dialect.SelectQuery]) OrderItemsQuery {
	PKArgSlice := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgSlice[i] = mysql.ArgGroup(o.ID)
	}
	PKArgExpr := mysql.Group(PKArgSlice...)

	return OrderItems.Query(append(mods,
		sm.Where(mysql.Group(OrderItems.Columns.OrderID).OP("IN", PKArgExpr)),
	)...)
}

// OrderPayments starts a query for related objects on order_payments
func (o *Order) OrderPayments(mods ...bob.Mod[*dialect.SelectQuery]) OrderPaymentsQuery {
	return OrderPayments.Query(append(mods,
		sm.Where(OrderPayments.Columns.OrderID.EQ(mysql.Arg(o.ID))),
	)...)
}

func (os OrderSlice) OrderPayments(mods ...bob.Mod[*dialect.SelectQuery]) OrderPaymentsQuery {
	PKArgSlice := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgSlice[i] = mysql.ArgGroup(o.ID)
	}
	PKArgExpr := mysql.Group(PKArgSlice...)

	return OrderPayments.Query(append(mods,
		sm.Where(mysql.Group(OrderPayments.Columns.OrderID).OP("IN", PKArgExpr)),
	)...)
}

// Customer starts a query for related objects on customers
func (o *Order) Customer(mods ...bob.Mod[*dialect.SelectQuery]) CustomersQuery {
	return Customers.Query(append(mods,
		sm.Where(Customers.Columns.ID.EQ(mysql.Arg(o.CustomerID))),
	)...)
}

func (os OrderSlice) Customer(mods ...bob.Mod[*dialect.SelectQuery]) CustomersQuery {
	PKArgSlice := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgSlice[i] = mysql.ArgGroup(o.CustomerID)
	}
	PKArgExpr := mysql.Group(PKArgSlice...)

	return Customers.Query(append(mods,
		sm.Where(mysql.Group(Customers.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

// Discount starts a query for related objects on discounts
func (o *Order) Discount(mods ...bob.Mod[*dialect.SelectQuery]) DiscountsQuery {
	return Discounts.Query(append(mods,
		sm.Where(Discounts.Columns.ID.EQ(mysql.Arg(o.DiscountID))),
	)...)
}

func (os OrderSlice) Discount(mods ...bob.Mod[*dialect.SelectQuery]) DiscountsQuery {
	PKArgSlice := make([]bob.Expression, len(os))
	for i, o := range os {
		PKArgSlice[i] = mysql.ArgGroup(o.DiscountID)
	}
	PKArgExpr := mysql.Group(PKArgSlice...)

	return Discounts.Query(append(mods,
		sm.Where(mysql.Group(Discounts.Columns.ID).OP("IN", PKArgExpr)),
	)...)
}

func insertOrderOrderItems0(ctx context.Context, exec bob.Executor, orderItems1 []*OrderItemSetter, order0 *Order) (OrderItemSlice, error) {
	for i := range orderItems1 {
		orderItems1[i].OrderID = omit.From(order0.ID)
	}

	ret, err := OrderItems.Insert(bob.ToMods(orderItems1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrderOrderItems0: %w", err)
	}

	return ret, nil
}

func attachOrderOrderItems0(ctx context.Context, exec bob.Executor, count int, orderItems1 OrderItemSlice, order0 *Order) (OrderItemSlice, error) {
	setter := &OrderItemSetter{
		OrderID: omit.From(order0.ID),
	}

	err := orderItems1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrderOrderItems0: %w", err)
	}

	return orderItems1, nil
}

func (order0 *Order) InsertOrderItems(ctx context.Context, exec bob.Executor, related ...*OrderItemSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	orderItems1, err := insertOrderOrderItems0(ctx, exec, related, order0)
	if err != nil {
		return err
	}

	order0.R.OrderItems = append(order0.R.OrderItems, orderItems1...)

	for _, rel := range orderItems1 {
		rel.R.Order = order0
	}
	return nil
}

func (order0 *Order) AttachOrderItems(ctx context.Context, exec bob.Executor, related ...*OrderItem) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	orderItems1 := OrderItemSlice(related)

	_, err = attachOrderOrderItems0(ctx, exec, len(related), orderItems1, order0)
	if err != nil {
		return err
	}

	order0.R.OrderItems = append(order0.R.OrderItems, orderItems1...)

	for _, rel := range related {
		rel.R.Order = order0
	}

	return nil
}

func insertOrderOrderPayments0(ctx context.Context, exec bob.Executor, orderPayments1 []*OrderPaymentSetter, order0 *Order) (OrderPaymentSlice, error) {
	for i := range orderPayments1 {
		orderPayments1[i].OrderID = omit.From(order0.ID)
	}

	ret, err := OrderPayments.Insert(bob.ToMods(orderPayments1...)).All(ctx, exec)
	if err != nil {
		return ret, fmt.Errorf("insertOrderOrderPayments0: %w", err)
	}

	return ret, nil
}

func attachOrderOrderPayments0(ctx context.Context, exec bob.Executor, count int, orderPayments1 OrderPaymentSlice, order0 *Order) (OrderPaymentSlice, error) {
	setter := &OrderPaymentSetter{
		OrderID: omit.From(order0.ID),
	}

	err := orderPayments1.UpdateAll(ctx, exec, *setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrderOrderPayments0: %w", err)
	}

	return orderPayments1, nil
}

func (order0 *Order) InsertOrderPayments(ctx context.Context, exec bob.Executor, related ...*OrderPaymentSetter) error {
	if len(related) == 0 {
		return nil
	}

	var err error

	orderPayments1, err := insertOrderOrderPayments0(ctx, exec, related, order0)
	if err != nil {
		return err
	}

	order0.R.OrderPayments = append(order0.R.OrderPayments, orderPayments1...)

	for _, rel := range orderPayments1 {
		rel.R.Order = order0
	}
	return nil
}

func (order0 *Order) AttachOrderPayments(ctx context.Context, exec bob.Executor, related ...*OrderPayment) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	orderPayments1 := OrderPaymentSlice(related)

	_, err = attachOrderOrderPayments0(ctx, exec, len(related), orderPayments1, order0)
	if err != nil {
		return err
	}

	order0.R.OrderPayments = append(order0.R.OrderPayments, orderPayments1...)

	for _, rel := range related {
		rel.R.Order = order0
	}

	return nil
}

func attachOrderCustomer0(ctx context.Context, exec bob.Executor, count int, order0 *Order, customer1 *Customer) (*Order, error) {
	setter := &OrderSetter{
		CustomerID: omitnull.From(customer1.ID),
	}

	err := order0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrderCustomer0: %w", err)
	}

	return order0, nil
}

func (order0 *Order) InsertCustomer(ctx context.Context, exec bob.Executor, related *CustomerSetter) error {
	var err error

	customer1, err := Customers.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachOrderCustomer0(ctx, exec, 1, order0, customer1)
	if err != nil {
		return err
	}

	order0.R.Customer = customer1

	customer1.R.Orders = append(customer1.R.Orders, order0)

	return nil
}

func (order0 *Order) AttachCustomer(ctx context.Context, exec bob.Executor, customer1 *Customer) error {
	var err error

	_, err = attachOrderCustomer0(ctx, exec, 1, order0, customer1)
	if err != nil {
		return err
	}

	order0.R.Customer = customer1

	customer1.R.Orders = append(customer1.R.Orders, order0)

	return nil
}

func attachOrderDiscount0(ctx context.Context, exec bob.Executor, count int, order0 *Order, discount1 *Discount) (*Order, error) {
	setter := &OrderSetter{
		DiscountID: omitnull.From(discount1.ID),
	}

	err := order0.Update(ctx, exec, setter)
	if err != nil {
		return nil, fmt.Errorf("attachOrderDiscount0: %w", err)
	}

	return order0, nil
}

func (order0 *Order) InsertDiscount(ctx context.Context, exec bob.Executor, related *DiscountSetter) error {
	var err error

	discount1, err := Discounts.Insert(related).One(ctx, exec)
	if err != nil {
		return fmt.Errorf("inserting related objects: %w", err)
	}

	_, err = attachOrderDiscount0(ctx, exec, 1, order0, discount1)
	if err != nil {
		return err
	}

	order0.R.Discount = discount1

	discount1.R.Orders = append(discount1.R.Orders, order0)

	return nil
}

func (order0 *Order) AttachDiscount(ctx context.Context, exec bob.Executor, discount1 *Discount) error {
	var err error

	_, err = attachOrderDiscount0(ctx, exec, 1, order0, discount1)
	if err != nil {
		return err
	}

	order0.R.Discount = discount1

	discount1.R.Orders = append(discount1.R.Orders, order0)

	return nil
}

type orderWhere[Q mysql.Filterable] struct {
	ID             mysql.WhereMod[Q, int64]
	OrderDate      mysql.WhereMod[Q, time.Time]
	CustomerID     mysql.WhereNullMod[Q, int64]
	DiscountID     mysql.WhereNullMod[Q, int64]
	OrderType      mysql.WhereMod[Q, string]
	Subtotal       mysql.WhereMod[Q, decimal.Decimal]
	DiscountAmount mysql.WhereMod[Q, decimal.Decimal]
	TaxAmount      mysql.WhereMod[Q, decimal.Decimal]
	Total          mysql.WhereMod[Q, decimal.Decimal]
	CreatedAt      mysql.WhereNullMod[Q, time.Time]
	UpdatedAt      mysql.WhereNullMod[Q, time.Time]
}

func (orderWhere[Q]) AliasedAs(alias string) orderWhere[Q] {
	return buildOrderWhere[Q](buildOrderColumns(alias))
}

func buildOrderWhere[Q mysql.Filterable](cols orderColumns) orderWhere[Q] {
	return orderWhere[Q]{
		ID:             mysql.Where[Q, int64](cols.ID),
		OrderDate:      mysql.Where[Q, time.Time](cols.OrderDate),
		CustomerID:     mysql.WhereNull[Q, int64](cols.CustomerID),
		DiscountID:     mysql.WhereNull[Q, int64](cols.DiscountID),
		OrderType:      mysql.Where[Q, string](cols.OrderType),
		Subtotal:       mysql.Where[Q, decimal.Decimal](cols.Subtotal),
		DiscountAmount: mysql.Where[Q, decimal.Decimal](cols.DiscountAmount),
		TaxAmount:      mysql.Where[Q, decimal.Decimal](cols.TaxAmount),
		Total:          mysql.Where[Q, decimal.Decimal](cols.Total),
		CreatedAt:      mysql.WhereNull[Q, time.Time](cols.CreatedAt),
		UpdatedAt:      mysql.WhereNull[Q, time.Time](cols.UpdatedAt),
	}
}

func (o *Order) Preload(name string, retrieved any) error {
	if o == nil {
		return nil
	}

	switch name {
	case "OrderItems":
		rels, ok := retrieved.(OrderItemSlice)
		if !ok {
			return fmt.Errorf("order cannot load %T as %q", retrieved, name)
		}

		o.R.OrderItems = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Order = o
			}
		}
		return nil
	case "OrderPayments":
		rels, ok := retrieved.(OrderPaymentSlice)
		if !ok {
			return fmt.Errorf("order cannot load %T as %q", retrieved, name)
		}

		o.R.OrderPayments = rels

		for _, rel := range rels {
			if rel != nil {
				rel.R.Order = o
			}
		}
		return nil
	case "Customer":
		rel, ok := retrieved.(*Customer)
		if !ok {
			return fmt.Errorf("order cannot load %T as %q", retrieved, name)
		}

		o.R.Customer = rel

		if rel != nil {
			rel.R.Orders = OrderSlice{o}
		}
		return nil
	case "Discount":
		rel, ok := retrieved.(*Discount)
		if !ok {
			return fmt.Errorf("order cannot load %T as %q", retrieved, name)
		}

		o.R.Discount = rel

		if rel != nil {
			rel.R.Orders = OrderSlice{o}
		}
		return nil
	default:
		return fmt.Errorf("order has no relationship %q", name)
	}
}

type orderPreloader struct {
	Customer func(...mysql.PreloadOption) mysql.Preloader
	Discount func(...mysql.PreloadOption) mysql.Preloader
}

func buildOrderPreloader() orderPreloader {
	return orderPreloader{
		Customer: func(opts ...mysql.PreloadOption) mysql.Preloader {
			return mysql.Preload[*Customer, CustomerSlice](mysql.PreloadRel{
				Name: "Customer",
				Sides: []mysql.PreloadSide{
					{
						From:        Orders,
						To:          Customers,
						FromColumns: []string{"customer_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Customers.Columns.Names(), opts...)
		},
		Discount: func(opts ...mysql.PreloadOption) mysql.Preloader {
			return mysql.Preload[*Discount, DiscountSlice](mysql.PreloadRel{
				Name: "Discount",
				Sides: []mysql.PreloadSide{
					{
						From:        Orders,
						To:          Discounts,
						FromColumns: []string{"discount_id"},
						ToColumns:   []string{"id"},
					},
				},
			}, Discounts.Columns.Names(), opts...)
		},
	}
}

type orderThenLoader[Q orm.Loadable] struct {
	OrderItems    func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	OrderPayments func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Customer      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
	Discount      func(...bob.Mod[*dialect.SelectQuery]) orm.Loader[Q]
}

func buildOrderThenLoader[Q orm.Loadable]() orderThenLoader[Q] {
	type OrderItemsLoadInterface interface {
		LoadOrderItems(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type OrderPaymentsLoadInterface interface {
		LoadOrderPayments(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type CustomerLoadInterface interface {
		LoadCustomer(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}
	type DiscountLoadInterface interface {
		LoadDiscount(context.Context, bob.Executor, ...bob.Mod[*dialect.SelectQuery]) error
	}

	return orderThenLoader[Q]{
		OrderItems: thenLoadBuilder[Q](
			"OrderItems",
			func(ctx context.Context, exec bob.Executor, retrieved OrderItemsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrderItems(ctx, exec, mods...)
			},
		),
		OrderPayments: thenLoadBuilder[Q](
			"OrderPayments",
			func(ctx context.Context, exec bob.Executor, retrieved OrderPaymentsLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadOrderPayments(ctx, exec, mods...)
			},
		),
		Customer: thenLoadBuilder[Q](
			"Customer",
			func(ctx context.Context, exec bob.Executor, retrieved CustomerLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadCustomer(ctx, exec, mods...)
			},
		),
		Discount: thenLoadBuilder[Q](
			"Discount",
			func(ctx context.Context, exec bob.Executor, retrieved DiscountLoadInterface, mods ...bob.Mod[*dialect.SelectQuery]) error {
				return retrieved.LoadDiscount(ctx, exec, mods...)
			},
		),
	}
}

// LoadOrderItems loads the order's OrderItems into the .R struct
func (o *Order) LoadOrderItems(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.OrderItems = nil

	related, err := o.OrderItems(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Order = o
	}

	o.R.OrderItems = related
	return nil
}

// LoadOrderItems loads the order's OrderItems into the .R struct
func (os OrderSlice) LoadOrderItems(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	orderItems, err := os.OrderItems(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.OrderItems = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range orderItems {

			if !(o.ID == rel.OrderID) {
				continue
			}

			rel.R.Order = o

			o.R.OrderItems = append(o.R.OrderItems, rel)
		}
	}

	return nil
}

// LoadOrderPayments loads the order's OrderPayments into the .R struct
func (o *Order) LoadOrderPayments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.OrderPayments = nil

	related, err := o.OrderPayments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, rel := range related {
		rel.R.Order = o
	}

	o.R.OrderPayments = related
	return nil
}

// LoadOrderPayments loads the order's OrderPayments into the .R struct
func (os OrderSlice) LoadOrderPayments(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	orderPayments, err := os.OrderPayments(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		o.R.OrderPayments = nil
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range orderPayments {

			if !(o.ID == rel.OrderID) {
				continue
			}

			rel.R.Order = o

			o.R.OrderPayments = append(o.R.OrderPayments, rel)
		}
	}

	return nil
}

// LoadCustomer loads the order's Customer into the .R struct
func (o *Order) LoadCustomer(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Customer = nil

	related, err := o.Customer(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Orders = OrderSlice{o}

	o.R.Customer = related
	return nil
}

// LoadCustomer loads the order's Customer into the .R struct
func (os OrderSlice) LoadCustomer(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	customers, err := os.Customer(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range customers {
			if !o.CustomerID.IsValue() {
				continue
			}

			if !(o.CustomerID.IsValue() && o.CustomerID.MustGet() == rel.ID) {
				continue
			}

			rel.R.Orders = append(rel.R.Orders, o)

			o.R.Customer = rel
			break
		}
	}

	return nil
}

// LoadDiscount loads the order's Discount into the .R struct
func (o *Order) LoadDiscount(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if o == nil {
		return nil
	}

	// Reset the relationship
	o.R.Discount = nil

	related, err := o.Discount(mods...).One(ctx, exec)
	if err != nil {
		return err
	}

	related.R.Orders = OrderSlice{o}

	o.R.Discount = related
	return nil
}

// LoadDiscount loads the order's Discount into the .R struct
func (os OrderSlice) LoadDiscount(ctx context.Context, exec bob.Executor, mods ...bob.Mod[*dialect.SelectQuery]) error {
	if len(os) == 0 {
		return nil
	}

	discounts, err := os.Discount(mods...).All(ctx, exec)
	if err != nil {
		return err
	}

	for _, o := range os {
		if o == nil {
			continue
		}

		for _, rel := range discounts {
			if !o.DiscountID.IsValue() {
				continue
			}

			if !(o.DiscountID.IsValue() && o.DiscountID.MustGet() == rel.ID) {
				continue
			}

			rel.R.Orders = append(rel.R.Orders, o)

			o.R.Discount = rel
			break
		}
	}

	return nil
}

type orderJoins[Q dialect.Joinable] struct {
	typ           string
	OrderItems    modAs[Q, orderItemColumns]
	OrderPayments modAs[Q, orderPaymentColumns]
	Customer      modAs[Q, customerColumns]
	Discount      modAs[Q, discountColumns]
}

func (j orderJoins[Q]) aliasedAs(alias string) orderJoins[Q] {
	return buildOrderJoins[Q](buildOrderColumns(alias), j.typ)
}

func buildOrderJoins[Q dialect.Joinable](cols orderColumns, typ string) orderJoins[Q] {
	return orderJoins[Q]{
		typ: typ,
		OrderItems: modAs[Q, orderItemColumns]{
			c: OrderItems.Columns,
			f: func(to orderItemColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, OrderItems.Name().As(to.Alias())).On(
						to.OrderID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		OrderPayments: modAs[Q, orderPaymentColumns]{
			c: OrderPayments.Columns,
			f: func(to orderPaymentColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, OrderPayments.Name().As(to.Alias())).On(
						to.OrderID.EQ(cols.ID),
					))
				}

				return mods
			},
		},
		Customer: modAs[Q, customerColumns]{
			c: Customers.Columns,
			f: func(to customerColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Customers.Name().As(to.Alias())).On(
						to.ID.EQ(cols.CustomerID),
					))
				}

				return mods
			},
		},
		Discount: modAs[Q, discountColumns]{
			c: Discounts.Columns,
			f: func(to discountColumns) bob.Mod[Q] {
				mods := make(mods.QueryMods[Q], 0, 1)

				{
					mods = append(mods, dialect.Join[Q](typ, Discounts.Name().As(to.Alias())).On(
						to.ID.EQ(cols.DiscountID),
					))
				}

				return mods
			},
		},
	}
}
