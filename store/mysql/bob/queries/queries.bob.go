// Code generated by BobGen mysql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package queries

import (
	"context"
	_ "embed"
	"io"
	"iter"
	"time"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/mysql"
	"github.com/stephenafamo/bob/dialect/mysql/dialect"
	"github.com/stephenafamo/bob/orm"
	"github.com/stephenafamo/scan"
)

//go:embed queries.bob.sql
var formattedQueries_queries string

var typedSalesSQL = formattedQueries_queries[149:776]

type TypedSalesQuery = orm.ModQuery[*dialect.SelectQuery, typedSales, TypedSalesRow, []TypedSalesRow, typedSalesTransformer]

func TypedSales(StartDate time.Time, EndDate time.Time) *TypedSalesQuery {
	var expressionTypArgs typedSales

	expressionTypArgs.StartDate = mysql.Arg(StartDate)
	expressionTypArgs.EndDate = mysql.Arg(EndDate)

	return &TypedSalesQuery{
		Query: orm.Query[typedSales, TypedSalesRow, []TypedSalesRow, typedSalesTransformer]{
			ExecQuery: orm.ExecQuery[typedSales]{
				BaseQuery: bob.BaseQuery[typedSales]{
					Expression: expressionTypArgs,
					Dialect:    dialect.Dialect,
					QueryType:  bob.QueryTypeSelect,
				},
			},
			Scanner: func(context.Context, []string) (func(*scan.Row) (any, error), func(any) (TypedSalesRow, error)) {
				return func(row *scan.Row) (any, error) {
						var t TypedSalesRow
						row.ScheduleScanByIndex(0, &t.Year)
						row.ScheduleScanByIndex(1, &t.Week)
						row.ScheduleScanByIndex(2, &t.Title)
						row.ScheduleScanByIndex(3, &t.ReportOrder)
						row.ScheduleScanByIndex(4, &t.Name)
						row.ScheduleScanByIndex(5, &t.Quantity)
						row.ScheduleScanByIndex(6, &t.TotalSales)
						return &t, nil
					}, func(v any) (TypedSalesRow, error) {
						return *(v.(*TypedSalesRow)), nil
					}
			},
		},
		Mod: bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {
			q.AppendSelect(expressionTypArgs.subExpr(7, 183))
			q.SetTable(expressionTypArgs.subExpr(189, 383))
			q.AppendWhere(expressionTypArgs.subExpr(390, 438))
			q.AppendGroup(expressionTypArgs.subExpr(448, 539))
			q.CombinedOrder.AppendOrder(expressionTypArgs.subExpr(549, 627))
		}),
	}
}

type TypedSalesRow = struct {
	Year        int32  `db:"year"`
	Week        string `db:"WEEK_OF_YEAR"`
	Title       string `db:"title"`
	ReportOrder int32  `db:"report_order"`
	Name        string `db:"name"`
	Quantity    string `db:"quantity"`
	TotalSales  string `db:"total_sales"`
}

type typedSalesTransformer = bob.SliceTransformer[TypedSalesRow, []TypedSalesRow]

type typedSales struct {
	StartDate bob.Expression
	EndDate   bob.Expression
}

func (o typedSales) args() iter.Seq[orm.ArgWithPosition] {
	return func(yield func(arg orm.ArgWithPosition) bool) {
		if !yield(orm.ArgWithPosition{
			Name:       "startDate",
			Start:      410,
			Stop:       411,
			Expression: o.StartDate,
		}) {
			return
		}

		if !yield(orm.ArgWithPosition{
			Name:       "endDate",
			Start:      437,
			Stop:       438,
			Expression: o.EndDate,
		}) {
			return
		}
	}
}

func (o typedSales) raw(from, to int) string {
	return typedSalesSQL[from:to]
}

func (o typedSales) subExpr(from, to int) bob.Expression {
	return orm.ArgsToExpression(typedSalesSQL, from, to, o.args())
}

func (o typedSales) WriteSQL(ctx context.Context, w io.StringWriter, d bob.Dialect, start int) ([]any, error) {
	return o.subExpr(0, len(typedSalesSQL)).WriteSQL(ctx, w, d, start)
}
