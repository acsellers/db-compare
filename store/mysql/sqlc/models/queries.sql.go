// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const createSale = `-- name: CreateSale :exec
insert into orders (order_date, customer_id, discount_id, order_type, subtotal, discount_amount, tax_amount, total)
values (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateSaleParams struct {
	OrderDate      time.Time
	CustomerID     sql.NullInt64
	DiscountID     sql.NullInt64
	OrderType      string
	Subtotal       string
	DiscountAmount string
	TaxAmount      string
	Total          string
}

func (q *Queries) CreateSale(ctx context.Context, arg CreateSaleParams) error {
	_, err := q.db.ExecContext(ctx, createSale,
		arg.OrderDate,
		arg.CustomerID,
		arg.DiscountID,
		arg.OrderType,
		arg.Subtotal,
		arg.DiscountAmount,
		arg.TaxAmount,
		arg.Total,
	)
	return err
}

const createSaleItems = `-- name: CreateSaleItems :exec
insert into order_items (order_id, product_id, discount_id, quantity, price, discount_amount)
values (?, ?, ?, ?, ?, ?)
`

type CreateSaleItemsParams struct {
	OrderID        int64
	ProductID      int64
	DiscountID     sql.NullInt64
	Quantity       int32
	Price          string
	DiscountAmount string
}

func (q *Queries) CreateSaleItems(ctx context.Context, arg CreateSaleItemsParams) error {
	_, err := q.db.ExecContext(ctx, createSaleItems,
		arg.OrderID,
		arg.ProductID,
		arg.DiscountID,
		arg.Quantity,
		arg.Price,
		arg.DiscountAmount,
	)
	return err
}

const createSalePayments = `-- name: CreateSalePayments :exec
insert into order_payments (order_id, payment_type, amount, payment_info)
values (?, ?, ?, ?)
`

type CreateSalePaymentsParams struct {
	OrderID     int64
	PaymentType string
	Amount      string
	PaymentInfo json.RawMessage
}

func (q *Queries) CreateSalePayments(ctx context.Context, arg CreateSalePaymentsParams) error {
	_, err := q.db.ExecContext(ctx, createSalePayments,
		arg.OrderID,
		arg.PaymentType,
		arg.Amount,
		arg.PaymentInfo,
	)
	return err
}

const customerSales = `-- name: CustomerSales :many
select customers.id, customers.name, 
  sum(orders.total) as total_sales, count(*) as total_orders
from customers
join orders on customers.id = orders.customer_id
where orders.order_date >= ? and orders.order_date <= ?
group by customers.id, customers.name
order by total_sales desc
`

type CustomerSalesParams struct {
	StartDate time.Time
	EndDate   time.Time
}

type CustomerSalesRow struct {
	ID          int64
	Name        string
	TotalSales  interface{}
	TotalOrders int64
}

func (q *Queries) CustomerSales(ctx context.Context, arg CustomerSalesParams) ([]CustomerSalesRow, error) {
	rows, err := q.db.QueryContext(ctx, customerSales, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerSalesRow
	for rows.Next() {
		var i CustomerSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalSales,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailyRevenue = `-- name: DailyRevenue :many
select order_type,sum(total) as total_revenue
from orders
where order_date >= ? and order_date <= ?
group by order_type
`

type DailyRevenueParams struct {
	StartDate time.Time
	EndDate   time.Time
}

type DailyRevenueRow struct {
	OrderType    string
	TotalRevenue interface{}
}

func (q *Queries) DailyRevenue(ctx context.Context, arg DailyRevenueParams) ([]DailyRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, dailyRevenue, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyRevenueRow
	for rows.Next() {
		var i DailyRevenueRow
		if err := rows.Scan(&i.OrderType, &i.TotalRevenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailySoldItems = `-- name: DailySoldItems :many
select id, name, category, 
cast(sum(total_quantity) as signed) as total_quantity, 
cast(sum(total_sales) as double) as total_sales
from item_summaries
where order_date = ?
group by id, name, category
order by category, name
`

type DailySoldItemsRow struct {
	ID            int64
	Name          string
	Category      string
	TotalQuantity int64
	TotalSales    float64
}

func (q *Queries) DailySoldItems(ctx context.Context, orderDate time.Time) ([]DailySoldItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, dailySoldItems, orderDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailySoldItemsRow
	for rows.Next() {
		var i DailySoldItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.TotalQuantity,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const generalSales = `-- name: GeneralSales :many
select ro.title, ro.report_order, t.name, 
sum(t.order_count) as order_count,
sum(t.total_quantity) as quantity,
sum(t.total_sales) as total_sales
from item_summaries t 
inner join reporting_order ro on ro.order_type = 'general' and ro.category = t.category
where t.order_date >= ? and t.order_date <= ?
group by ro.title, ro.report_order, t.name 
order by ro.report_order, t.name
`

type GeneralSalesParams struct {
	StartDate time.Time
	EndDate   time.Time
}

type GeneralSalesRow struct {
	Title       string
	ReportOrder int32
	Name        string
	OrderCount  interface{}
	Quantity    interface{}
	TotalSales  interface{}
}

func (q *Queries) GeneralSales(ctx context.Context, arg GeneralSalesParams) ([]GeneralSalesRow, error) {
	rows, err := q.db.QueryContext(ctx, generalSales, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeneralSalesRow
	for rows.Next() {
		var i GeneralSalesRow
		if err := rows.Scan(
			&i.Title,
			&i.ReportOrder,
			&i.Name,
			&i.OrderCount,
			&i.Quantity,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDiscount = `-- name: GetDiscount :many
SELECT id, name, category, discount_type, discount, created_at, updated_at FROM discounts WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetDiscount(ctx context.Context, ids []int64) ([]Discount, error) {
	query := getDiscount
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Discount
	for rows.Next() {
		var i Discount
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.DiscountType,
			&i.Discount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, category, price, created_at, updated_at FROM products WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetProducts(ctx context.Context, ids []int64) ([]Product, error) {
	query := getProducts
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSale = `-- name: GetSale :one
select orders.id, orders.order_date, orders.customer_id, orders.discount_id, orders.order_type, orders.subtotal, orders.discount_amount, orders.tax_amount, orders.total, orders.created_at, orders.updated_at, customers.name
from orders 
left join customers on orders.customer_id = customers.id
where orders.id = ?
`

type GetSaleRow struct {
	ID             int64
	OrderDate      time.Time
	CustomerID     sql.NullInt64
	DiscountID     sql.NullInt64
	OrderType      string
	Subtotal       string
	DiscountAmount string
	TaxAmount      string
	Total          string
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Name           sql.NullString
}

func (q *Queries) GetSale(ctx context.Context, id int64) (GetSaleRow, error) {
	row := q.db.QueryRowContext(ctx, getSale, id)
	var i GetSaleRow
	err := row.Scan(
		&i.ID,
		&i.OrderDate,
		&i.CustomerID,
		&i.DiscountID,
		&i.OrderType,
		&i.Subtotal,
		&i.DiscountAmount,
		&i.TaxAmount,
		&i.Total,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
	)
	return i, err
}

const getSaleItems = `-- name: GetSaleItems :many
select order_items.id, order_items.order_id, order_items.product_id, order_items.discount_id, order_items.quantity, order_items.price, order_items.discount_amount, order_items.created_at, order_items.updated_at, 
  products.name, products.category 
from order_items 
left join products on order_items.product_id = products.id
where order_items.order_id = ?
`

type GetSaleItemsRow struct {
	ID             int64
	OrderID        int64
	ProductID      int64
	DiscountID     sql.NullInt64
	Quantity       int32
	Price          string
	DiscountAmount string
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Name           sql.NullString
	Category       sql.NullString
}

func (q *Queries) GetSaleItems(ctx context.Context, orderID int64) ([]GetSaleItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSaleItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSaleItemsRow
	for rows.Next() {
		var i GetSaleItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.DiscountID,
			&i.Quantity,
			&i.Price,
			&i.DiscountAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalePayments = `-- name: GetSalePayments :many
select id, order_id, payment_type, amount, payment_info, created_at, updated_at from order_payments where order_id = ?
`

func (q *Queries) GetSalePayments(ctx context.Context, orderID int64) ([]OrderPayment, error) {
	rows, err := q.db.QueryContext(ctx, getSalePayments, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderPayment
	for rows.Next() {
		var i OrderPayment
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.PaymentType,
			&i.Amount,
			&i.PaymentInfo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCustomers = `-- name: InsertCustomers :exec
INSERT INTO customers (name, email, phone) VALUES (?, ?, ?)
`

type InsertCustomersParams struct {
	Name  string
	Email sql.NullString
	Phone sql.NullString
}

func (q *Queries) InsertCustomers(ctx context.Context, arg InsertCustomersParams) error {
	_, err := q.db.ExecContext(ctx, insertCustomers, arg.Name, arg.Email, arg.Phone)
	return err
}

const insertCustomersBulk = `-- name: InsertCustomersBulk :copyfrom
INSERT INTO customers  (name, phone, email)  
VALUES (?, ?, ?)
`

type InsertCustomersBulkParams struct {
	Name  string
	Phone sql.NullString
	Email sql.NullString
}

const searchSales = `-- name: SearchSales :many
select orders.id, orders.order_date, orders.customer_id, orders.discount_id, orders.order_type, orders.subtotal, orders.discount_amount, orders.tax_amount, orders.total, orders.created_at, orders.updated_at, customers.name
from orders 
left join customers on orders.customer_id = customers.id
where (customers.name like @name or @name = '')
and (orders.order_date >= @order_start or @order_start = '')
and (orders.order_date <= @order_end or @order_end = '')
and (orders.order_type = @order_type or @order_type = '')
and (orders.total >= @total_start or @total_start = 0)
and (orders.total <= @total_end or @total_end = 0)
order by orders.order_date desc
`

type SearchSalesRow struct {
	ID             int64
	OrderDate      time.Time
	CustomerID     sql.NullInt64
	DiscountID     sql.NullInt64
	OrderType      string
	Subtotal       string
	DiscountAmount string
	TaxAmount      string
	Total          string
	CreatedAt      sql.NullTime
	UpdatedAt      sql.NullTime
	Name           sql.NullString
}

func (q *Queries) SearchSales(ctx context.Context) ([]SearchSalesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSales)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSalesRow
	for rows.Next() {
		var i SearchSalesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderDate,
			&i.CustomerID,
			&i.DiscountID,
			&i.OrderType,
			&i.Subtotal,
			&i.DiscountAmount,
			&i.TaxAmount,
			&i.Total,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const weeklyTypedSales = `-- name: WeeklyTypedSales :many
select dim_date.year, dim_date.WEEK_OF_YEAR, ro.title, ro.report_order, t.name, 
sum(t.order_count) as order_count,
sum(t.total_quantity) as quantity,
sum(t.total_sales) as total_sales
from item_summaries t 
inner join reporting_order ro on ro.order_type = t.order_type and ro.category = t.category
inner join dim_date on dim_date.date = t.order_date
where t.order_date >= ? and t.order_date <= ?
group by dim_date.year, dim_date.WEEK_OF_YEAR,ro.title, ro.report_order, t.name 
order by dim_date.year, dim_date.WEEK_OF_YEAR, ro.report_order, t.name
`

type WeeklyTypedSalesParams struct {
	StartDate time.Time
	EndDate   time.Time
}

type WeeklyTypedSalesRow struct {
	Year        int32
	WeekOfYear  int32
	Title       string
	ReportOrder int32
	Name        string
	OrderCount  interface{}
	Quantity    interface{}
	TotalSales  interface{}
}

func (q *Queries) WeeklyTypedSales(ctx context.Context, arg WeeklyTypedSalesParams) ([]WeeklyTypedSalesRow, error) {
	rows, err := q.db.QueryContext(ctx, weeklyTypedSales, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeeklyTypedSalesRow
	for rows.Next() {
		var i WeeklyTypedSalesRow
		if err := rows.Scan(
			&i.Year,
			&i.WeekOfYear,
			&i.Title,
			&i.ReportOrder,
			&i.Name,
			&i.OrderCount,
			&i.Quantity,
			&i.TotalSales,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
