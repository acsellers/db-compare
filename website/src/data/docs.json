{
  "Examples": {
    "bulk_customers": "# Bulk Customer Load\n\nMost applications will need some way to load mass amounts of data into the database. \n\nThis example is limited to whatever the mapper supports. The simplest solution is to just\nrun a bunch of insert statements, using a prepared statement. A better solution is to have\nmultiple rows per insert statement.\n\nThe gold standard is for the mapper to support the special bulk load statements, like LOAD DATA\nINFILE for Mysql or COPY INTO for Postgres. \n\nThis example has three sub-tests: a 10,000 row test, a 1,000,000 row test, and a 100,000,000 row test.",
    "create_sale": "# Create Sale\n\nThis example demonstrates a semi-secure solution for creating a sale record, along with the associated\nitems and payment records. I say semi-secure because there isn't any verification of discount to \nsales, but products and discounts are loaded from the database and calculations are performed\nserver-side, then compared the expected total. \n\nThis example demonstrates pulling records by id and inserting one record along with multiple\nchild records. Some mapper libraries could allow the \ndeveloper to insert the parent and children in a single \ncall, while some libaries on the other side require\nsetting the parent id on each child record individually.",
    "customer_sales": "# Customer Sales\n\nThis is a pretty simple join and group by query. It\njoins from customer to orders, then groups by customer\nid and name, the gets order count and order total over\na time period.",
    "daily_revenue": "# Daily Revenue \u0026 Daily Sold Items\n\nThese are two pretty simple group by queries. The Daily \nRevenue query is pulling from a table while the Daily \nSold Items query is pulling from a view.\n",
    "general_sales": "# General Sales \u0026 Typed Sales Reports\n\nThese are two group by queries that need to be joined\non fields that are not foreign keys. \n\nThe General Sales report joins a view to a \nreporting category table, but only to the \"general\"\ncategory labels.\n\nThe Typed Sales report joins a view to a \nreporting category table, but it joins on category\nand order type. ",
    "get_sale": "",
    "json_fields": "# JSON Fields\n\nEver since document databases became popular, developers have realized the power of \nstuffing json objects into columns. When you have a bunch of attributes that don't\nreally get queried, but need to be stored, you reach for a JSON column.\n\nIdeally, the database mapper will automatically marshal and unmarshal the json \nstruct in and out of the column. That's the ideal case, but it's not always present\nin the mapper libraries.",
    "order_search": "# Order Search\n\nThis query is about multiple optional conditions to\nfilter customers and orders. Ideally, only the used \nfilter conditions are included in the query, but some \nmapping librariies don't make that easy.\n\n",
    "update_customer": "# Update Customer\n\nWhile the customer record in this schema doesn't have \nmany columns, most customer tables will have plenty of\ndifferent columns to update. This example demonstrates\nhow the mapping library handles updating specific \ncolumns.\n\nDoes the mapping library really only have single column\nor all column upates? Or can the mapping library update\ncolumns dynamically?"
  },
  "Libraries": {
    "bob": "# Bob\n\nBob is a library that generates a custom query library\nfrom the live schema of the database. \n\n## Pros\n\n* Table mapping is generated for the columns and does\nnot require reflection.\n* Map tables and views, with relationships and type-specific query helpers.\n* Has a fallback reflection-based struct mapper.\n* Select specific columns, preload related tables, \n\n## Cons\n\n* Need to be careful about generating the models when\nfeature branches have introduced new columns.",
    "sqlc": "# SQLC\n\nLet's be honest, this was the simplest library to setup\nfor this project. Every table and query was fully \nspecified before implementation as part of planning.\nThe only changes I had to make was to add the names for\nthe query parameters.\n\n## Pros\n\n* If you're good at writing SQL, this is going to provide\na simple way to generate a good query library.\n* Type specific query structs per query.\n* Share structs within queries.\n\n## Cons\n\n* You're writing every single query, even the simple ones.\n* You might need to write a lot of update queries or commit to updating all the columns.\n* Some queries might need to be written in a fall-back\nmanner to handle optional parameters.\n"
  },
  "ReportCards": {
    "bob": {
      "name": "bob",
      "website": "https://bob.stephenafamo.com/",
      "repo": "https://github.com/stephenafamo/bob",
      "description": "SQL query builder and ORM/Factory generator for Go with support for PostgreSQL, MySQL and SQLite",
      "databases": [
        "postgres",
        "mysql",
        "sqlite"
      ],
      "license": "MIT",
      "features": [
        "ORM",
        "Mapper",
        "Query Builder",
        "Factory"
      ],
      "grades": {
        "get_sale": {
          "level": "gold",
          "notes": "Able to eagerly load sub-records in one call"
        },
        "create_sale": {
          "level": "silver",
          "notes": "Unable to insert sale with sub-records, but able to insert sub-records using a helper after creating the sale"
        },
        "customer_update": {
          "level": "gold",
          "notes": "Able to update only modified fields"
        },
        "customer_sales": {
          "level": "gold",
          "notes": "Able to use foreign key relationships for joins, also maps to arbitrary structs"
        },
        "daily_reports": {
          "level": "gold",
          "notes": "Able to group and specify columns easily, would like to see a way to alias a function to a name"
        },
        "sales_reports": {
          "level": "gold",
          "notes": "Able to specify arbitrary joins, would like to see a way to alias a function to a name"
        },
        "sale_search": {
          "level": "gold",
          "notes": "Able to specify individual filters as needed"
        },
        "bulk_customers": {
          "level": "silver",
          "notes": "Unable to use Load Data Infile, but able to use regular insert with many rows"
        },
        "json": {
          "level": "bronze",
          "notes": "No auto-marshalling/unmarshalling of JSON columns or json query helpers, json columns are recognized as json types"
        }
      }
    },
    "sqlc": {
      "name": "sqlc",
      "website": "https://sqlc.dev/",
      "repo": "https://github.com/sqlc-dev/sqlc",
      "description": "Compile SQL to type-safe code; catch failures before they happen.",
      "databases": [
        "postgres",
        "mysql",
        "sqlite"
      ],
      "license": "MIT",
      "features": [
        "Mapper",
        "Query Builder"
      ],
      "grades": {
        "get_sale": {
          "level": "bronze",
          "notes": "Needed to pull each record type separately"
        },
        "create_sale": {
          "level": "bronze",
          "notes": "Unable to insert sale with sub-records, and needed to iterate over the sub-records to insert them after setting the parent sale id"
        },
        "customer_update": {
          "level": "bronze",
          "notes": "Needed to use multiple queries or a query that updates all the fields to update customers"
        },
        "customer_sales": {
          "level": "gold",
          "notes": "Able to use foreign key relationships for joins, also maps to arbitrary structs"
        },
        "daily_reports": {
          "level": "gold",
          "notes": "Able to group and specify columns easily, would like to see a way to alias a function to a name"
        },
        "sales_reports": {
          "level": "gold",
          "notes": "Able to specify arbitrary joins, would like to see a way to alias a function to a name"
        },
        "sale_search": {
          "level": "gold",
          "notes": "Able to specify individual filters as needed"
        },
        "bulk_customers": {
          "level": "silver",
          "notes": "Unable to use Load Data Infile, but able to use regular insert with many rows"
        },
        "json": {
          "level": "bronze",
          "notes": "No auto-marshalling/unmarshalling of JSON columns or json query helpers, json columns are recognized as json types"
        }
      }
    }
  }
}