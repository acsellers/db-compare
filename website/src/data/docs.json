{
  "Examples": {
    "bulk_customers": "# Bulk Customer Load\n\nMost applications will need some way to load mass amounts of data into the database. \n\nThis example is limited to whatever the mapper supports. The simplest solution is to just\nrun a bunch of insert statements, using a prepared statement. A better solution is to have\nmultiple rows per insert statement.\n\nThe gold standard is for the mapper to support the special bulk load statements, like LOAD DATA\nINFILE for Mysql or COPY INTO for Postgres. \n\nThis example has three sub-tests: a 10,000 row test, a 1,000,000 row test, and a 100,000,000 row test.",
    "create_sale": "# Create Sale\n\nThis example demonstrates a semi-secure solution for creating a sale record, along with the associated\nitems and payment records. I say semi-secure because there isn't any verification of discount to \nsales, but products and discounts are loaded from the database and calculations are performed\nserver-side, then compared the expected total. \n\nThis example demonstrates pulling records by id and inserting one record along with multiple\nchild records. Some mapper libraries could allow the \ndeveloper to insert the parent and children in a single \ncall, while some libaries on the other side require\nsetting the parent id on each child record individually.",
    "customer_sales": "# Customer Sales\n\nThis is a pretty simple join and group by query. It\njoins from customer to orders, then groups by customer\nid and name, the gets order count and order total over\na time period.",
    "daily_revenue": "# Daily Revenue \u0026 Daily Sold Items\n\nThese are two pretty simple group by queries. The Daily \nRevenue query is pulling from a table while the Daily \nSold Items query is pulling from a view.\n",
    "general_sales": "# General Sales \u0026 Typed Sales Reports\n\nThese are two group by queries that need to be joined\non fields that are not foreign keys. \n\nThe General Sales report joins a view to a \nreporting category table, but only to the \"general\"\ncategory labels.\n\nThe Typed Sales report joins a view to a \nreporting category table, but it joins on category\nand order type. ",
    "get_sale": "",
    "order_search": "",
    "update_customer": "# Update Customer\n\nWhile the customer record in this schema doesn't have \nmany columns, most customer tables will have plenty of\ndifferent columns to update. This example demonstrates\nhow the mapping library handles updating specific \ncolumns.\n\nDoes the mapping library really only have single column\nor all column upates? Or can the mapping library update\ncolumns dynamically?"
  },
  "Libraries": {
    "bob": "# Bob\n\nBob is a library that generates a custom query library\nfrom the live schema of the database. \n\n## Pros\n\n* Table mapping is generated for the columns and does\nnot require reflection.\n* Map tables and views, with relationships and type-specific query helpers.\n* Has a fallback reflection-based struct mapper.\n* Select specific columns, preload related tables, \n\n## Cons\n\n* Need to be careful about generating the models when\nfeature branches have introduced new columns.",
    "sqlc": "# SQLC\n\nLet's be honest, this was the simplest library to setup\nfor this project. Every table and query was fully \nspecified before implementation as part of planning.\nThe only changes I had to make was to add the names for\nthe query parameters.\n\n## Pros\n\n* If you're good at writing SQL, this is going to provide\na simple way to generate a good query library.\n* Type specific query structs per query.\n* Share structs within queries.\n\n## Cons\n\n* You're writing every single query, even the simple ones.\n* You might need to write a lot of update queries or commit to updating all the columns.\n* Some queries might need to be written in a fall-back\nmanner to handle optional parameters.\n"
  }
}